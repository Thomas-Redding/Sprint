#pragma once

#include <string>

enum TokenType {
	AMPERSAND_EQUALS,
	AMPERSAND,
	ARROW,
	ASTERISK_ASTERISK_EQUALS,
	ASTERISK_ASTERISK,
	ASTERISK_EQUALS,
	ASTERISK,
	AT,
	BACK_SLASH_EQUALS,
	BACK_SLASH,
	BRACKET,
	CARROT_EQUALS,
	CARROT,
	CHARACTER_LITERAL,
	CLOSE_BRACKET,
	CLOSE_CURLY_BRACE,
	CLOSE_PARENTHESIS,
	CLOSE_TEMPLATE,
	COLON_EQUALS,
	COLON,
	COMMA,
	EQUAL_EQUAL_EQUALS,
	EQUAL_EQUALS,
	EQUALS,
	EXCLAMATION_POINT_EQUAL_EQUALS,
	EXCLAMATION_POINT_EQUALS,
	EXCLAMATION_POINT,
	FLOAT_LITERAL,
	FLOAT_LITERAL2,
	GREATER_THAN_EQUALS,
	GREATER_THAN,
	IDENTIFIER,
	INTEGER_LITERAL,
	KEYWORD_AND,
	KEYWORD_BOOL,
	KEYWORD_BREAK,
	KEYWORD_CASE,
	KEYWORD_CATCH,
	KEYWORD_CHAR,
	KEYWORD_CLASS,
	KEYWORD_COMMUTE,
	KEYWORD_CONST,
	KEYWORD_CONTINUE,
	KEYWORD_DEFAULT,
	KEYWORD_DO,
	KEYWORD_DOUBLE,
	KEYWORD_ELSE,
	KEYWORD_ENUM,
	KEYWORD_FALSE,
	KEYWORD_FLOAT,
	KEYWORD_FOR,
	KEYWORD_IF,
	KEYWORD_IMPORT,
	KEYWORD_IN,
	KEYWORD_INFINITY,
	KEYWORD_INT,
	KEYWORD_INT16,
	KEYWORD_INT32,
	KEYWORD_INT8,
	KEYWORD_IS,
	KEYWORD_MUT,
	KEYWORD_NAMESPACE,
	KEYWORD_NAN,
	KEYWORD_NOT,
	KEYWORD_NULL,
	KEYWORD_OR,
	KEYWORD_PRIVATE,
	KEYWORD_PUBLIC,
	KEYWORD_REPEAT,
	KEYWORD_RETURN,
	KEYWORD_SIZEOF,
	KEYWORD_STATIC,
	KEYWORD_SWITCH, 
	KEYWORD_THIS,
	KEYWORD_THROW,
	KEYWORD_TRUE,
	KEYWORD_TRY,
	KEYWORD_UINT,
	KEYWORD_UINT16,
	KEYWORD_UINT32,
	KEYWORD_UINT8,
	KEYWORD_VAR,
	KEYWORD_VOID,
	KEYWORD_WHILE,
	KEYWORD_XOR,
	KEYWORD,
	LEFT_ARROW,
	LEFT_RIGHT_ARROW,
	LESS_THAN_EQUALS,
	LESS_THAN,
	MINUS_EQUALS,
	MINUS_MINUS,
	MINUS,
	NEGATIVE,
	NULL_TOKEN_TYPE,
	OPEN_BRACKET,
	OPEN_CURLY_BRACE,
	OPEN_PARENTHESIS,
	OPEN_TEMPLATE,
	PERCENT_EQUALS,
	PERCENT,
	PERIOD,
	PLUS_EQUALS,
	PLUS_PLUS,
	PLUS,
	POSITIVE,
	POUND_SIGN,
	PUNCTUATION,
	QUESTION_MARK,
	SEMI_COLON,
	SHIFT_LEFT_EQUALS,
	SHIFT_LEFT,
	SHIFT_RIGHT_EQUALS,
	SHIFT_RIGHT,
	SLASH_EQUALS,
	SLASH,
	STRING_LITERAL,
	TILDE,
	UNKNOWN,
	VERTICAL_BAR_EQUALS,
	VERTICAL_BAR
};

bool is_int(TokenType type);

class Token {
public:
	Token() {
	}
	Token(TokenType ty) {
		type = ty;
		str = "";
	}
	Token(TokenType ty, std::string st) {
		type = ty;
		str = st;
	}
	Token(TokenType ty, std::string st, long ln, long cn) {
		type = ty;
		str = st;
		lineNum = ln;
		charNum = cn;
	}
	const bool halfEquals(Token ty) {
		if(ty.str == "" || str == "")
			return type == ty.type;
		return equals(ty);
	}
	const bool equals(Token ty) {
		if(type == ty.type && str == ty.str)
			return true;
		return false;
	}
	std::string toString() const {
		return "(" + toString(type) + " '" + str + "' ~ " + std::to_string(lineNum) + "," + std::to_string(charNum) + ")";
	}
	bool isPrimitive() const {
		return is_int(type) || type == KEYWORD_DOUBLE || type == KEYWORD_FLOAT || type == KEYWORD_VAR;
	}
	bool isLiteral() const {
		return type == INTEGER_LITERAL || type == FLOAT_LITERAL || type == FLOAT_LITERAL2 || type == CHARACTER_LITERAL || type == STRING_LITERAL;
	}
	TokenType type;
	std::string str;
	long lineNum;
	long charNum;

	static std::string toString(const TokenType& t) {
		std::string arr[121] = {"AMPERSAND_EQUALS", "AMPERSAND", "ARROW", "ASTERISK_ASTERISK_EQUALS", "ASTERISK_ASTERISK", "ASTERISK_EQUALS", "ASTERISK", "AT", "BACK_SLASH_EQUALS", "BACK_SLASH", "BRACKET", "CARROT_EQUALS", "CARROT", "CHARACTER_LITERAL", "CLOSE_BRACKET", "CLOSE_CURLY_BRACE", "CLOSE_PARENTHESIS", "CLOSE_TEMPLATE", "COLON_EQUALS", "COLON", "COMMA", "EQUAL_EQUAL_EQUALS", "EQUAL_EQUALS", "EQUALS", "EXCLAMATION_POINT_EQUAL_EQUALS", "EXCLAMATION_POINT_EQUALS", "EXCLAMATION_POINT", "FLOAT_LITERAL", "FLOAT_LITERAL2", "GREATER_THAN_EQUALS", "GREATER_THAN", "IDENTIFIER", "INTEGER_LITERAL", "KEYWORD_AND", "KEYWORD_BOOL", "KEYWORD_BREAK", "KEYWORD_CASE", "KEYWORD_CATCH", "KEYWORD_CHAR", "KEYWORD_CLASS", "KEYWORD_COMMUTE", "KEYWORD_CONST", "KEYWORD_CONTINUE", "KEYWORD_DEFAULT", "KEYWORD_DO", "KEYWORD_DOUBLE", "KEYWORD_ELSE", "KEYWORD_ENUM", "KEYWORD_FALSE", "KEYWORD_FLOAT", "KEYWORD_FOR", "KEYWORD_IF", "KEYWORD_IMPORT", "KEYWORD_IN", "KEYWORD_INFINITY", "KEYWORD_INT", "KEYWORD_INT16", "KEYWORD_INT32", "KEYWORD_INT8", "KEYWORD_IS", "KEYWORD_MUT", "KEYWORD_NAMESPACE", "KEYWORD_NAN", "KEYWORD_NOT", "KEYWORD_NULL", "KEYWORD_OR", "KEYWORD_PRIVATE", "KEYWORD_PUBLIC", "KEYWORD_REPEAT", "KEYWORD_RETURN", "KEYWORD_SIZEOF", "KEYWORD_STATIC", "KEYWORD_SWITCH",  "KEYWORD_THIS", "KEYWORD_THROW", "KEYWORD_TRUE", "KEYWORD_TRY", "KEYWORD_UINT", "KEYWORD_UINT16", "KEYWORD_UINT32", "KEYWORD_UINT8", "KEYWORD_VAR", "KEYWORD_VOID", "KEYWORD_WHILE", "KEYWORD_XOR", "KEYWORD", "LEFT_ARROW", "LEFT_RIGHT_ARROW", "LESS_THAN_EQUALS", "LESS_THAN", "MINUS_EQUALS", "MINUS_MINUS", "MINUS", "NEGATIVE", "NULL_TOKEN_TYPE", "OPEN_BRACKET", "OPEN_CURLY_BRACE", "OPEN_PARENTHESIS", "OPEN_TEMPLATE", "PERCENT_EQUALS", "PERCENT", "PERIOD", "PLUS_EQUALS", "PLUS_PLUS", "PLUS", "POSITIVE", "POUND_SIGN", "PUNCTUATION", "QUESTION_MARK", "SEMI_COLON", "SHIFT_LEFT_EQUALS", "SHIFT_LEFT", "SHIFT_RIGHT_EQUALS", "SHIFT_RIGHT", "SLASH_EQUALS", "SLASH", "STRING_LITERAL", "TILDE", "UNKNOWN", "VERTICAL_BAR_EQUALS", "VERTICAL_BAR"};
		return arr[int(t)];
	}
	static std::string toString(const Token& t) {
		return toString(t.type);
	}

	friend std::ostream& operator<<(std::ostream& stream, const Token& t) {
		return stream << t.toString();
	}

};